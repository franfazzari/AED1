Index: auxiliares.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#include \"definiciones.h\"\r\n#include \"auxiliares.h\"\r\n#include \"gtest/gtest.h\"\r\n#include \"ejercicios.h\"\r\n#include \"math.h\"\r\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n                                                //AUXILIARES PARA esEncuestaValida DEL PUNTO 1:\r\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nbool esMatriz(vector<vector <int>> t){\r\n    bool res = true;\r\n    if (t.size() ==1){\r\n        return res;\r\n    }\r\n    for (int i = 0; i < t.size() -1 ; ++i){\r\n        if (t[i].size() != t[i+1].size()){\r\n            res = false;\r\n            return res;\r\n        }\r\n    } return res;\r\n}\r\n\r\nbool esCantidadCorrectaDeColumnasI(eph_i ti){\r\n    bool res = true;\r\n    for (int i = 0; i < ti.size() ; ++i) {\r\n        if(ti[i].size() != 11){\r\n            res = false;\r\n            return res;\r\n        }\r\n    }\r\n    return res;\r\n}\r\n\r\nbool esCantidadCorrectaDeColumnasH(eph_h th){\r\n    bool res = true;\r\n    for (int h = 0; h < th.size() ; ++h) {\r\n        if(th[h].size() != 12){\r\n            res = false;\r\n            return res;\r\n        }\r\n    }\r\n    return res;\r\n}\r\n\r\n//Mismo caso que en nohayhogaressinindividuos//\r\nbool noHayIndividuosSinHogares(eph_h th, eph_i ti){\r\n    bool res = false;\r\n    for(int i=0; i < ti.size(); i++){\r\n        for(int h=0; h < th.size(); h++){\r\n            if(th[h][0] == ti[i][0]){\r\n                res = true;\r\n                break;\r\n            } else {\r\n                if (h == th.size()-1){\r\n                    return res = false;}\r\n            }\r\n        }\r\n    }\r\n    return res;\r\n}\r\n\r\nbool noHayHogaresSinIndividuos(eph_h th, eph_i ti){\r\n    bool res = false;\r\n    for(int h=0; h < th.size(); h++){\r\n        for(int i=0; i < ti.size(); i++){\r\n            if(ti[i][0] == th[h][0]){\r\n                res = true;\r\n                break;\r\n            } else {\r\n                if (i == ti.size()-1) {\r\n                    return res = false;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return res;\r\n}\r\n\r\nbool noHayIndividuosRepetidos(eph_i ti){\r\n    bool res = true;\r\n    for(int i=0; i < ti.size() - 1; i++){\r\n        for (int j = i + 1; j <ti.size() ; ++j) {\r\n            if(ti[i][0] == ti[j][0] && ti[i][2] == ti[j][2]){\r\n                return res = false;\r\n            }\r\n        }\r\n    }\r\n    return res;\r\n}\r\n\r\nbool noHayHogaresRepetidos(eph_h th){\r\n    bool res = true;\r\n    for(int h=0; h < th.size() ; h++){\r\n        for (int j = h + 1; j <th.size() ; ++j) {\r\n            if(th[h][0] == th[j][0]) {\r\n                return res = false;\r\n            }\r\n        }\r\n    }\r\n    return res;\r\n}\r\n\r\nbool esMismoAnioYTrimestre(eph_h th, eph_i ti) {\r\n    bool res = true;\r\n    int anio = ti[0][INDANIO];\r\n    int trimestre = ti[0][INDTRIMESTRE];\r\n    for (int i = 1; i < ti.size(); ++i) {\r\n        if (ti[i][INDTRIMESTRE] != trimestre || ti[i][INDANIO] != anio){\r\n            res = false;\r\n            return res;\r\n        }\r\n    }\r\n    for (int h = 0; h < th.size(); ++h) {\r\n        if (th[h][HOGANIO] != anio || th[h][HOGTRIMESTRE] != trimestre) {\r\n            res = false;\r\n            return res;\r\n        }\r\n    }\r\n    return res;\r\n}\r\n\r\nbool menosDe21MiembrosPorHogar(eph_h th, eph_i ti){\r\n    bool res = true;\r\n    for(int h=0; h < th.size(); h++){\r\n        if(cantidadDeHabitantes(th[h], ti) >20){\r\n            return res = false;}\r\n    }\r\n    return res;\r\n}\r\n\r\nbool cantidadValidaDormitorios(eph_h th){\r\n    bool res = true;\r\n    for(int h=0; h < th.size(); h++) {\r\n        if (th[h][IV2] < th[h][II2]) {\r\n            return res = false;\r\n        }\r\n    }\r\n    return res;\r\n}\r\n\r\nbool esRegionValida(hogar h){\r\n    bool res = false;\r\n    if(h[REGION] == 1 || 40 <= h[REGION] <= 44) {\r\n        return res = true;\r\n    }\r\n    return res;\r\n}\r\n\r\nbool losValoresEstanEnRangoH(eph_h th){\r\n    bool res = true;\r\n    for(int h=0; h < th.size(); h++){\r\n        if(th[h][HOGCODUSU] <= 0 || th[h][HOGTRIMESTRE] < 1 || th[h][HOGTRIMESTRE] > 4 || th[h][II7] < 1 || th[h][II7] > 3\r\n           || !esRegionValida(th[h]) || th[h][MAS_500] < 0 || th[h][MAS_500] > 1 || th[h][IV1] < 1 || th[h][IV1] > 5 ||\r\n           th[h][IV2] < 1 || th[h][II2] < 1 || th[h][II3] < 1 || th[h][II3] > 2){\r\n            return res = false;\r\n        }\r\n    }\r\n    return res;\r\n}\r\n\r\nbool esIngresoValido(individuo i){\r\n    bool res = false;\r\n    if(i[p47T] >= -1){\r\n        res = true;\r\n    }\r\n    return res;\r\n}\r\n\r\nbool losValoresEstanEnRangoI(eph_i ti){\r\n    bool res = true;\r\n    for(int i=0; i < ti.size(); i++){\r\n        if(ti[i][INDCODUSU] <= 0 || ti[i][COMPONENTE] <= 0 || ti[i][INDTRIMESTRE] < 1 || ti[i][INDTRIMESTRE] > 4 ||\r\n           ti[i][CH4] < 1 || ti[i][CH4] > 2 || ti[i][CH6] < 0 || ti[i][NIVEL_ED] < 0 || ti[i][NIVEL_ED] > 1 ||\r\n           ti[i][ESTADO] < -1 || ti[i][ESTADO] > 1 || ti[i][CAT_OCUP] < 0 || ti[i][CAT_OCUP] > 4 || !esIngresoValido(ti[i])\r\n           || ti[i][PP04G] < 0 || ti[i][PP04G] > 10){\r\n            return res = false;\r\n        }\r\n    }\r\n    return res;\r\n}\r\n\r\nbool esSuHogar (hogar h, individuo i){\r\n    bool resp = false;\r\n    if (h[HOGCODUSU] == i[INDCODUSU]){\r\n        resp = true;\r\n    }\r\n    return resp;\r\n}\r\n\r\nint cantidadDeHabitantes (hogar h, eph_i ti){\r\n    int contador = 0;\r\n    for (int i = 0; i < ti.size(); ++i) {\r\n        if (esSuHogar(h,ti[i])){\r\n            contador++;\r\n        }\r\n    }\r\n    return contador;\r\n}\r\n\r\n\r\n\r\nbool esValida(eph_h th, eph_i ti){\r\n    bool res = true;\r\n    if(th.size() == 0 || ti.size() == 0 || !esMatriz(th) || !esMatriz(ti) || !esCantidadCorrectaDeColumnasH(th)\r\n       || !esCantidadCorrectaDeColumnasI(ti) || !noHayIndividuosSinHogares(ti, th) || !noHayIndividuosSinHogares(th, ti)\r\n       || !noHayHogaresSinIndividuos(th, ti) || !noHayHogaresRepetidos(th) || !noHayIndividuosRepetidos(ti) ||\r\n       !esMismoAnioYTrimestre(th, ti) || !menosDe21MiembrosPorHogar(th, ti) || !cantidadValidaDormitorios(th) ||\r\n       !losValoresEstanEnRangoI(ti) || !losValoresEstanEnRangoH(th)){\r\n\r\n        res = false;\r\n    }\r\n    return res;\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n                                        //AUXILIARES PARA histHabitacional DEL PUNTO 2:\r\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nint cantidadMaximadeHabitacionesEnRegionDada (eph_h th, int region){\r\n    int res = 0;\r\n    for (int i = 0; i < th.size(); i++){\r\n        if (th[i][REGION] == region && th[i][IV1] == 1 && th[i][IV2] > res){\r\n\r\n            res = th[i][IV2];\r\n            \r\n        }\r\n    }\r\n    return res;\r\n}\r\n\r\nint cantidadCasasConiHabitacionesEnRegionDada (eph_h th, int region, int k){\r\n    int res = 0;\r\n    for (int i = 0; i < th.size(); i++){\r\n        if (th[i][REGION] == region && th[i][IV1] == 1 && th[i][IV2] == k){\r\n            res++;\r\n        }\r\n    }\r\n    return res;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n                                //AUXILIARES PARA laCasaEstaQuedandoChica DEL PUNTO 3:\r\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nbool esHogarConHacinamientoCritico(hogar h, eph_i ti){\r\n    bool res = false;\r\n    if(cantidadDeHabitantes(h, ti) > 3*h[IV2] ){\r\n        res = true;\r\n    }\r\n    return res;\r\n}\r\n\r\nbool esHogarValido (hogar h, dato region){\r\n    if (h[IV1]==1 && h[REGION]==region && h[MAS_500]==0){\r\n        return true;\r\n    } else {\r\n        return false;\r\n    }\r\n}\r\n\r\nint cantidadDeHogaresValidos(eph_h th, dato region){\r\n    int res = 0;\r\n    for (int h = 0; h < th.size(); ++h) {\r\n        if (esHogarValido(th[h], region)){\r\n            res++;\r\n        }\r\n    }\r\n    return res;\r\n}\r\nint cantidadDeHogaresValidosConHC(eph_h th, eph_i ti, int region){\r\n    int res = 0;\r\n    for(int h=0; h < th.size(); h++){\r\n        if(esHogarValido(th[h],region) && esHogarConHacinamientoCritico (th[h], ti)){\r\n            res++;\r\n        }\r\n    }\r\n    return res;\r\n}\r\n\r\n\r\nfloat proporcionHogaresConHC(eph_h th, eph_i ti, dato region){\r\n    float res = 0;\r\n    if (cantidadDeHogaresValidos(th,region) > 0){\r\n    res = cantidadDeHogaresValidosConHC(th, ti, region) / cantidadDeHogaresValidos(th, region);\r\n    }\r\n    return res;\r\n}\r\n\r\n\r\n\r\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n                                        //AUXILIARES PARA proporcionTeleworking DEL PUNTO 4:\r\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n\r\nbool esCasaODepartamento (hogar h) {\r\n    bool res = false;\r\n    if (h[IV1] == 1 || h[IV1] == 2){\r\n        res = true;\r\n    }\r\n    return res;\r\n}\r\n\r\nbool trabaja (individuo i){\r\n    bool res = i[ESTADO] == 1;\r\n    return res;\r\n}\r\n\r\nbool suHogarEsCasaODepartamento(individuo i, eph_h th){\r\n    bool res = false;\r\n    for (int h = 0; h < th.size(); ++h) {\r\n        if (esSuHogar(th[h],i) && esCasaODepartamento (th[h])){\r\n            res = true;\r\n            return res;\r\n        }\r\n    }\r\n    return res;\r\n}\r\n\r\nbool esDeCiudadGrande (individuo i, eph_h th){\r\n    bool res = false;\r\n    for (int h = 0; h < th.size(); ++h) {\r\n        if (esSuHogar(th[h],i) && th[h][MAS_500] == 1){\r\n            res = true;\r\n            return res;\r\n        }\r\n    }\r\n    return res;\r\n}\r\n\r\nbool individuoEnHogarValido (individuo i, eph_h th){\r\n    bool res = false;\r\n    if (esDeCiudadGrande (i,th) && suHogarEsCasaODepartamento(i,th)){\r\n        res = true;\r\n    }\r\n    return res;\r\n}\r\n\r\nfloat cantIndividuosQueTrabajan (eph_h th, eph_i ti) {\r\n    float contador = 0;\r\n    for (int i = 0; i < ti.size(); ++i) {\r\n        if (trabaja(ti[i]) && individuoEnHogarValido(ti[i], th)){\r\n            contador ++;\r\n        }\r\n    }\r\n    return contador;\r\n}\r\n\r\nbool tieneEspaciosReservadosParaElTrabajo(hogar h){\r\n    bool resp = false;\r\n    if (h[II3] == 1){\r\n        resp = true;\r\n    }\r\n    return resp;\r\n}\r\n\r\nbool suHogarTieneEspaciosReservadosParaElTrabajo(individuo i, eph_h th){\r\n    bool resp = false;\r\n    for (int h = 0; h < th.size() ; ++h) {\r\n        if (esSuHogar(th[h],i) && tieneEspaciosReservadosParaElTrabajo(th[h])){\r\n            resp = true;\r\n            return resp;\r\n        }\r\n    }\r\n    return resp;\r\n}\r\n\r\nbool realizaSusTareasEnEsteHogar(individuo i){\r\n    bool resp = false;\r\n    if (i[PP04G] == 6){\r\n        resp = true;\r\n    }\r\n    return resp;\r\n}\r\n\r\nbool trabajaEnSuVivienda (individuo i, eph_h th){\r\n    bool resp = false;\r\n    if(realizaSusTareasEnEsteHogar(i) && suHogarTieneEspaciosReservadosParaElTrabajo(i, th)){\r\n        resp = true;\r\n    }\r\n    return resp;\r\n}\r\n\r\nfloat cantIndividuosTrabajandoEnSuVivienda (eph_h th, eph_i ti) {\r\n    float contador = 0;\r\n    for (int i = 0; i < ti.size(); ++i) {\r\n        if (trabaja (ti[i]) && individuoEnHogarValido (ti[i], th) && trabajaEnSuVivienda(ti[i],th)){\r\n            contador++;\r\n        }\r\n    }\r\n    return contador;\r\n}\r\n\r\nfloat proporcionTeleworking (eph_h th, eph_i ti) {\r\n    float resp = 0;\r\n    if (cantIndividuosQueTrabajan (th,ti)>0){\r\n        resp = (cantIndividuosTrabajandoEnSuVivienda (th,ti) )/ (cantIndividuosQueTrabajan (th,ti));\r\n    }\r\n    return resp;\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n                                        //AUXILIARES PARA costoSubsidioMejora DEL PUNTO 5:\r\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nbool tieneCasaPropia (hogar h){\r\n    bool resp = false;\r\n    return resp = h[II7] == 1;\r\n}\r\n\r\n\r\n\r\nbool tieneCasaChica (hogar h, eph_i ti){\r\n    bool resp = false;\r\n    if ((cantidadDeHabitantes(h, ti) -2) > h[II2]){\r\n        resp = true;\r\n    }\r\n    return resp;\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n                                //AUXILIARES PARA ordenarRegionYCODUSU DEL PUNTO 7:\r\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\nvoid ordenarPorCodusuTh(eph_h &th){\r\n    for (int j = 0; j < th.size(); j++){\r\n        for (int i = 0; i < th.size()-1; i++){\r\n            if (th[i][HOGCODUSU] > th[i+1][HOGCODUSU]){\r\n                hogar temp;\r\n                temp = th[i];\r\n                th[i] = th[i+1];\r\n                th[i+1] = temp;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nvoid ordenarPorRegiones(eph_h &th){\r\n    for (int j = 0; j < th.size(); j++){\r\n        for (int i = 0; i < th.size()-1; i++){\r\n            if (th[i][REGION] > th[i+1][REGION]){\r\n                hogar temp;\r\n                temp = th[i];\r\n                th[i] = th[i+1];\r\n                th[i+1] = temp;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nvoid ordenarPorComponenteTi (eph_i &ti){\r\n    for (int j = 0; j < ti.size(); j++){\r\n        for (int i = 0; i < ti.size()-1; i++){\r\n            if (ti[i][COMPONENTE] > ti[i+1][COMPONENTE]){\r\n                individuo temp;\r\n                temp = ti[i];\r\n                ti[i] = ti[i+1];\r\n                ti[i+1] = temp;\r\n            }\r\n        }\r\n    }\r\n}\r\nvector < int > listaDeHogcodususOrdenados (eph_h th){\r\n    vector <int> result;\r\n    for (int i = 0; i < th.size(); i++) {\r\n        if (!perteneceAlVector(result,th[i][HOGCODUSU])) {\r\n            result.push_back(th[i][HOGCODUSU]);\r\n        }\r\n    }\r\n    return result;\r\n}\r\n\r\nbool perteneceAlVector(vector <int> v, int n){\r\n    bool result = false;\r\n    for (int i = 0; i < v.size(); i++){\r\n        if (v[i] == n){\r\n            result = true;\r\n        }\r\n    }\r\n    return result;\r\n}\r\n\r\nbool primerCodusuEstaAntes (dato primer, dato segundo, vector <int> l){\r\n    bool res = false;\r\n    int i = 0;\r\n    int j = 0;\r\n    for (; i < l.size(); i++){\r\n        if (l[i] == primer){\r\n            break;\r\n        }\r\n    }\r\n    for (;j < l.size(); j++){\r\n        if (l[j] == segundo){\r\n            break;\r\n        }\r\n    }\r\n    if ( i < j){\r\n        res = true;\r\n    }\r\n    return res;\r\n}\r\n\r\nvoid ordenarPorCODUSUTi (eph_i &ti, const vector <int> lista){\r\n    for (int j = 0; j < ti.size() ; j++) {\r\n      for (int i = 0; i < ti.size() - 1; i++){\r\n        if (primerCodusuEstaAntes(ti[i+1][HOGCODUSU], ti[i][HOGCODUSU], lista)) {\r\n            individuo temp;\r\n            temp = ti[i];\r\n            ti[i] = ti[i + 1];\r\n            ti[i + 1] = temp;\r\n            }\r\n        }\r\n    }\r\n\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n                                    //AUXILIARES PARA muestraHomogenea DEL PUNTO 8:\r\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nint ingresosHogar (eph_i ti, int hogcodusu){\r\n        int ingresosHogar = 0;\r\n        for (int i = 0; i < ti.size(); i++){\r\n            if (ti[i][INDCODUSU] == hogcodusu && ti[i][p47T] != -1){\r\n                ingresosHogar = ingresosHogar + ti[i][p47T];\r\n            }\r\n        }\r\n        return ingresosHogar;\r\n}\r\n\r\nvector <pair<int,int>> listaHogaresConIngresos (eph_h th, eph_i ti){\r\n    vector <pair<int,int>> v;\r\n    for (int i = 0; i < th.size(); i++){\r\n        pair <int,int> temp;\r\n        temp.first = th[i][HOGCODUSU];\r\n        temp.second = ingresosHogar(ti,th[i][HOGCODUSU]);\r\n        v.push_back(temp);\r\n    }\r\n    return v;\r\n}\r\n\r\nvoid ordenarHogaresPorIngresos (vector <pair<int,int>> &l){\r\n    for (int j = 0; j < l.size(); j++) {\r\n        for (int i = 0; i < l.size() - 1; i++) {\r\n            if (l[i].second > l[i + 1].second) {\r\n                pair<int, int> temp;\r\n                temp = l[i];\r\n                l[i] = l[i + 1];\r\n                l[i + 1] = temp;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nbool perteneceALista (int valor, vector <pair<int,int>> &l){\r\n    bool res = false;\r\n    for (int i = 0; i < l.size()-1; i++){\r\n        if (valor == l[i].second){\r\n            res = true;\r\n        }\r\n    }\r\n    return res;\r\n}\r\n\r\n\r\nvector<int> listaDeHogaresOptimos (vector <pair<int,int>> listaIngresos){\r\n    vector<int> listaDePosicionesMayor = {0,1};\r\n    vector<int> listaDePosicionesTemporal;\r\n    for (int k = 0; k < listaIngresos.size(); ++k) {\r\n        for (int m = k+1; m < listaIngresos.size()-1; ++m) {\r\n            listaDePosicionesTemporal= {k,m};\r\n            int diferencia = listaIngresos[m].second - listaIngresos[k].second;\r\n            for (int n = m+1; n < listaIngresos.size(); ++n) {\r\n                if (listaIngresos[n].second-listaIngresos[m].second == diferencia){\r\n                    listaDePosicionesTemporal.push_back(n);\r\n                    m=n;\r\n                } else { if (listaIngresos[n].second-listaIngresos[m].second > diferencia){\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            if(listaDePosicionesTemporal.size() > listaDePosicionesMayor.size()){\r\n                listaDePosicionesMayor = listaDePosicionesTemporal;\r\n            }\r\n        }\r\n    }\r\n    vector<int> listaHogcodusu;\r\n    for (int i = 0; i < listaDePosicionesMayor.size(); ++i) {\r\n        for (int j = 0; j < listaIngresos.size(); ++j) {\r\n            if (listaDePosicionesMayor[i] == j){\r\n                listaHogcodusu.push_back(listaIngresos[j].first);\r\n                break;\r\n\r\n            }\r\n        }\r\n    }\r\n    return listaHogcodusu;\r\n}\r\n\r\nint laDifferenciaQueMasAparece (vector <pair<int,int>> &l) {\r\n    int maxDif = l[l.size()-1].second - l[0].second;\r\n    int aparicionesMax = 0;\r\n    int difQueMasAparece = 0;\r\n    for (int i = 1 ; i < maxDif; i++) {\r\n        int qAparicionesi = 0;\r\n        for (int j = 1; j < l.size() - 1; j++) {\r\n            if (perteneceALista((l[0].second + (i * j)), l)) {\r\n                qAparicionesi++;\r\n            }\r\n        }\r\n        if (qAparicionesi > aparicionesMax){\r\n            difQueMasAparece = i;\r\n            aparicionesMax = qAparicionesi;\r\n        }\r\n    }\r\n    return difQueMasAparece;\r\n}\r\n\r\nvector <int> hogcodususDeDifs(int valor, vector <pair<int,int>> &l){\r\n    vector <int> v;\r\n    for (int i = 0; i < l.size(); i++){\r\n        for (int j = 1; j < l.size(); j++){\r\n            if (l[i].second == j*valor){\r\n                v.push_back(l[i].first);\r\n            }\r\n        }\r\n    }\r\n    return v;\r\n}\r\n\r\nvector <hogar> listaDeHogaresFinales(eph_h &th, vector <int> &l){\r\n    vector <hogar> res;\r\n    int j = 0;\r\n    for (int i = 0; i < th.size(); i++){\r\n        if (l[j] == th[i][HOGCODUSU]){\r\n            res.push_back(th[i]);\r\n            j++;\r\n            i = 0;\r\n        }\r\n    }\r\n    return res;\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n                                   //AUXILIARES PARA corregirRegion DEL PUNTO 9:\r\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvoid cambiaRegionGBAaPampeana(eph_h th){\r\n    for(int h=0; h < th.size(); h++){\r\n        if(th[h][REGION] == GBA){\r\n            th[h][REGION] = PAMPEANA;\r\n        }\r\n    }\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n                                   //AUXILIARES PARA quitarIndividuos DEL PUNTO 10:\r\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nbool cumpleBusqueda(individuo ind, vector <pair <int,dato> > busqueda){\r\n    bool res = true;\r\n    for(int b=0; b < busqueda.size(); b++){\r\n        if (ind[busqueda[b].first] != busqueda[b].second){\r\n            return res = false;\r\n        }\r\n    }\r\n    return res;\r\n}\r\n\r\nvector< vector<int> > tablaIndividuos(eph_i ti, vector <pair <int,dato> > busqueda){\r\n\r\n    vector< vector<int> > tablaI;                 //creo la tabla donde voy a ir guardando los individuos que cumplan con la búsqueda\r\n    for(int i=0; i < ti.size(); i++){     //\"voy a chequear cada dato que busco, de a uno...\"\r\n        if (cumpleBusqueda(ti[i], busqueda)){     //\"y si el valor del dato que busco, en ese individuo coincide con el que quiero encontrar..\"\r\n            tablaI.push_back(ti[i]);              //entonces lo agrego a la tabla que voy a returnear.\r\n        }\r\n    }\r\n    return tablaI;\r\n}\r\n\r\n\r\nvector< vector<int> > tablaHogares(eph_h th, eph_i ti, vector <pair <int,dato> > busqueda){\r\n    vector< vector<int> > tablaH;\r\n    vector<vector<int>> tablaI = tablaIndividuos(ti, busqueda);\r\n    for(int h=0; h < th.size(); h++){\r\n        for(int i=0; i < tablaI.size(); i++){\r\n            if(tablaI[i][INDCODUSU] == th[h][HOGCODUSU]){\r\n                tablaH.push_back(th[h]);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    return tablaH;\r\n}\r\n\r\nvector< vector<int> > restoDeTablaIndividuos(eph_i ti,  vector <pair <int,dato> > busqueda){\r\n    vector< vector<int> > tablaIR;\r\n\r\n    for(int i=0; i < ti.size(); i++){\r\n        if (!cumpleBusqueda(ti[i], busqueda)){\r\n            tablaIR.push_back(ti[i]);\r\n        }\r\n    }\r\n    return tablaIR;\r\n}\r\n\r\n\r\nvector< vector<int> > restoDeTablaHogares(eph_h th, eph_i ti,  vector <pair <int,dato> > busqueda){\r\n    vector< vector<int> > tablaHR;\r\n    vector<vector<int>> tablaI = restoDeTablaIndividuos(ti, busqueda);\r\n    for(int h=0; h < th.size(); h++) {\r\n        for (int i = 0; i < tablaI.size(); i++){\r\n            if (tablaI[i][INDCODUSU] == th[h][HOGCODUSU]) {\r\n                tablaHR.push_back(th[h]);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    return tablaHR;\r\n}\r\n\r\n\r\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n                                   //AUXILIARES PARA histogramaDeAnillosConcentricos DEL PUNTO 11:\r\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nint cuadrado(int a){\r\n    int b;\r\n    return b = a*a;\r\n}\r\n\r\nfloat distanciaEuclideana(pair < float, float > centro, float latitud, float longitud){\r\n    float res;\r\n    return res = sqrt(cuadrado(centro.first - latitud) + cuadrado(centro.second - longitud));\r\n}\r\n\r\nbool estaElHogarEnAnillo(int distDesde, int distHasta, pair < int, int > centro, hogar hog){\r\n    bool res = false;\r\n    if(distDesde < distanciaEuclideana(centro, hog[HOGLATITUD], hog[HOGLONGITUD]) &&\r\n    distanciaEuclideana(centro, hog[HOGLATITUD], hog[HOGLONGITUD]) <= distHasta){\r\n        res = true;\r\n    }\r\n    return res;\r\n}\r\n\r\nint cantidadDeHogaresPorAnillo(int distDesde, int distHasta, pair < int, int > centro, eph_h th){\r\n    int res = 0;\r\n    for(int k=0; k < th.size(); k++){\r\n        if(estaElHogarEnAnillo(distDesde, distHasta, centro, th[k])){\r\n            res = res + 1;\r\n        }\r\n    }\r\n    return res;\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/auxiliares.cpp b/auxiliares.cpp
--- a/auxiliares.cpp	
+++ b/auxiliares.cpp	
@@ -517,21 +517,21 @@
 ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 
 int ingresosHogar (eph_i ti, int hogcodusu){
-        int ingresosHogar = 0;
-        for (int i = 0; i < ti.size(); i++){
-            if (ti[i][INDCODUSU] == hogcodusu && ti[i][p47T] != -1){
-                ingresosHogar = ingresosHogar + ti[i][p47T];
-            }
-        }
-        return ingresosHogar;
+    int res = 0;
+    for (int i = 0; i < ti.size(); i++){
+        if (ti[i][INDCODUSU] == hogcodusu && ti[i][p47T] != -1){
+            res = res + ti[i][p47T];
+        }
+    }
+    return res;
 }
 
-vector <pair<int,int>> listaHogaresConIngresos (eph_h th, eph_i ti){
+vector<pair<int,int>> listaHogaresConIngresos (eph_h th, eph_i ti){
     vector <pair<int,int>> v;
-    for (int i = 0; i < th.size(); i++){
+    for (int h = 0; h < th.size(); h++){
         pair <int,int> temp;
-        temp.first = th[i][HOGCODUSU];
-        temp.second = ingresosHogar(ti,th[i][HOGCODUSU]);
+        temp.first = th[h][HOGCODUSU];
+        temp.second = ingresosHogar(ti,th[h][HOGCODUSU]);
         v.push_back(temp);
     }
     return v;
@@ -595,7 +595,7 @@
     return listaHogcodusu;
 }
 
-int laDifferenciaQueMasAparece (vector <pair<int,int>> &l) {
+    int laDifferenciaQueMasAparece (vector <pair<int,int>> &l) {
     int maxDif = l[l.size()-1].second - l[0].second;
     int aparicionesMax = 0;
     int difQueMasAparece = 0;
Index: ejercicios.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#include \"ejercicios.h\"\r\n#include \"auxiliares.h\"\r\n#include \"definiciones.h\"\r\n\r\nusing namespace std;\r\n\r\n// Implementacion Problema 1\r\nbool esEncuestaValida ( eph_h th, eph_i ti ) {\r\n\tbool resp = esValida(th, ti);\r\n\treturn resp;\r\n}\r\n\r\n// Implementacion Problema 2\r\nvector < int > histHabitacional ( eph_h th, eph_i ti, int region ) {\r\n\tint largo = cantidadMaximadeHabitacionesEnRegionDada(th, region);\r\n\tvector < int > resultado;\r\n\tfor (int i = 1; i <= largo; i++){\r\n\t\tresultado.push_back(cantidadCasasConiHabitacionesEnRegionDada (th, region, i));\r\n\t}\r\n\treturn resultado;\r\n}\r\n\r\n// Implementacion Problema 3\r\nvector< pair < int, float > > laCasaEstaQuedandoChica ( eph_h th, eph_i ti ) {\r\n\r\n    vector<pair<int,float>> resp = {make_pair(1,-1.0),\r\n                                    make_pair(40, -1.0),\r\n                                    make_pair(41, -1.0),\r\n                                    make_pair(42,-1.0),\r\n                                    make_pair(43,-1.0),\r\n                                    make_pair(44,-1.0)};\r\n\r\n    resp[0].second = proporcionHogaresConHC(th, ti, 1);\r\n    for (int k = 1; k < CANTIDAD_DE_REGIONES; k++) {\r\n        resp[k].second = proporcionHogaresConHC(th, ti, 40 + k);\r\n    }\r\n    return resp;\r\n}\r\n\r\n// Implementacion Problema 4\r\nbool creceElTeleworkingEnCiudadesGrandes ( eph_h t1h, eph_i t1i, eph_h t2h, eph_i t2i ) {\r\n    bool resp = false;\r\n    if ( proporcionTeleworking (t2h,t2i) > proporcionTeleworking (t1h, t1i)){\r\n        resp = true;\r\n    }\r\n    return  resp;\r\n}\r\n\r\n// Implementacion Problema 5\r\nint costoSubsidioMejora( eph_h th, eph_i ti, int monto ){\r\n    int resp = 0;\r\n    for (int h = 0; h < th.size(); ++h) {\r\n        if (tieneCasaPropia (th[h]) && tieneCasaChica (th[h], ti)){\r\n            resp = resp + monto;\r\n        }\r\n    }\r\n    return resp;\r\n}\r\n\r\n// Implementacion Problema 6\r\njoin_hi generarJoin( eph_h th, eph_i ti ){\r\n    hogar h = {};\r\n    individuo i = {};\r\n    join_hi resp (ti.size());\r\n\r\n    for (int k = 0; k < ti.size(); ++k) { //Voy dupla por dupla agregando los individuos de ti\r\n        for (int j = k; j < resp.size(); ++j) {\r\n            resp[j].second = ti[k];\r\n            break;\r\n        }\r\n\r\n    } // Hasta acá la dupla debería tener en la segunda posicion un individuo\r\n    for (int j = 0; j < resp.size(); ++j) {\r\n        for (int k = 0; k < th.size(); ++k) { //Acá veo dupla por dupla, si el hogcodusu de th coincide con el ind de la dupla entonces lo mete\r\n            if (resp[j].second[INDCODUSU] == th[k][HOGCODUSU]) {\r\n                resp[j].first = th[k];\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    return  resp;\r\n}\r\n\r\n// Implementacion Problema 7\r\nvoid ordenarRegionYCODUSU (eph_h & th, eph_i & ti) {\r\n        // PROBADO FUNCIONA\r\n        ordenarPorCodusuTh(th);\r\n        ordenarPorRegiones(th);\r\n        ordenarPorComponenteTi(ti);\r\n        vector <int> lista = listaDeHogcodususOrdenados(th);\r\n        ordenarPorCODUSUTi(ti,lista);\r\n        return;\r\n    }\r\n\r\n\r\n\r\n// Implementacion Problema 8\r\n\r\nvector < hogar > muestraHomogenea( eph_h & th, eph_i & ti ){\r\n    eph_h resp;\r\n    vector <pair <int,int>> hogaresConIngresos = listaHogaresConIngresos(th,ti);\r\n    ordenarHogaresPorIngresos(hogaresConIngresos);\r\n    vector <pair <int,int>> listaOrdenadaHogaresIngresos = hogaresConIngresos;\r\n    vector<int> listaDeMejoresHogares = listaDeHogaresOptimos(listaOrdenadaHogaresIngresos);\r\n    if (listaDeMejoresHogares.size()>=3){\r\n        for (int i = 0; i < listaDeMejoresHogares.size(); ++i) {\r\n            for (int h = 0; h < th.size(); ++h) {\r\n                if (listaDeMejoresHogares[i] == th[h][HOGCODUSU]){\r\n                    resp.push_back(th[h]);\r\n                    break;\r\n                }\r\n\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n    return resp;\r\n}\r\n/*\r\nvector < hogar > muestraHomogenea( eph_h & th, eph_i & ti ){\r\n    hogar h = {};\r\n    vector < hogar > resp = {h};\r\n\r\n    //Formar la lista de hogares con sus Ingresos\r\n    vector <pair <int,int>> hogaresConIngresos = listaHogaresConIngresos(th,ti);\r\n    // Ordenar la lista de hogares por ingresos de manera creciente\r\n    ordenarHogaresPorIngresos(hogaresConIngresos);\r\n    // Buscar la differencia mas grande\r\n    int difMax = laDifferenciaQueMasAparece(hogaresConIngresos);\r\n    vector <int> v = hogcodususDeDifs(difMax, hogaresConIngresos);\r\n    resp = listaDeHogaresFinales( th, v);\r\n    return resp; */\r\n\r\n\r\n// Implementacion Problema 9\r\nvoid corregirRegion( eph_h & th, eph_i ti ) {\r\n\tif(esEncuestaValida(th, ti)){\r\n        cambiaRegionGBAaPampeana(th);\r\n    }\r\n\treturn;\r\n}\r\n\r\n// Implementacion Problema 10\r\npair < eph_h, eph_i > quitarIndividuos(eph_i &ti, eph_h &th, vector <pair <int,dato> > busqueda){\r\n    eph_h rth = {{-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}};\r\n    eph_i rti = {{-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}};\r\n    pair < eph_h, eph_i > resp = make_pair(rth, rti);\r\n\r\n    eph_h th0 = th;\r\n    eph_i ti0 = ti;\r\n\r\n    ti = restoDeTablaIndividuos(ti0, busqueda);\r\n    th = restoDeTablaHogares(th0, ti0, busqueda);\r\n\r\n    resp.first = tablaHogares(th0, ti0, busqueda);\r\n    resp.second = tablaIndividuos(ti0, busqueda);\r\n\r\n    return resp;\r\n}\r\n\r\n// Implementacion Problema 11\r\nvector < int > histogramaDeAnillosConcentricos(eph_h th, eph_i ti, pair < int, int > centro, vector < int > distancias) {\r\n    vector<int> resp = {};\r\n    resp.push_back(cantidadDeHogaresPorAnillo(0, distancias[0], centro, th));\r\n    for (int k = 1; k < distancias.size(); k++) {\r\n        resp.push_back (cantidadDeHogaresPorAnillo(distancias[k - 1], distancias[k], centro, th));\r\n    }\r\n    return resp;\r\n}\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/ejercicios.cpp b/ejercicios.cpp
--- a/ejercicios.cpp	
+++ b/ejercicios.cpp	
@@ -90,10 +90,8 @@
         vector <int> lista = listaDeHogcodususOrdenados(th);
         ordenarPorCODUSUTi(ti,lista);
         return;
-    }
+}
 
-
-
 // Implementacion Problema 8
 
 vector < hogar > muestraHomogenea( eph_h & th, eph_i & ti ){
@@ -118,20 +116,20 @@
     return resp;
 }
 /*
-vector < hogar > muestraHomogenea( eph_h & th, eph_i & ti ){
+vector < hogar > muestraHomogenea( eph_h & th, eph_i & ti ) {
     hogar h = {};
-    vector < hogar > resp = {h};
+    vector <hogar> resp = {h};
 
     //Formar la lista de hogares con sus Ingresos
-    vector <pair <int,int>> hogaresConIngresos = listaHogaresConIngresos(th,ti);
+    vector <pair<int, int>> hogaresConIngresos = listaHogaresConIngresos(th, ti);
     // Ordenar la lista de hogares por ingresos de manera creciente
     ordenarHogaresPorIngresos(hogaresConIngresos);
     // Buscar la differencia mas grande
     int difMax = laDifferenciaQueMasAparece(hogaresConIngresos);
-    vector <int> v = hogcodususDeDifs(difMax, hogaresConIngresos);
-    resp = listaDeHogaresFinales( th, v);
+    vector<int> v = hogcodususDeDifs(difMax, hogaresConIngresos);
+    resp = listaDeHogaresFinales(th, v);
     return resp; */
-
+}
 
 // Implementacion Problema 9
 void corregirRegion( eph_h & th, eph_i ti ) {
Index: .idea/modules.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project version=\"4\">\r\n  <component name=\"ProjectModuleManager\">\r\n    <modules>\r\n      <module fileurl=\"file://$PROJECT_DIR$/.idea/TPI.iml\" filepath=\"$PROJECT_DIR$/.idea/TPI.iml\" />\r\n    </modules>\r\n  </component>\r\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/modules.xml b/.idea/modules.xml
--- a/.idea/modules.xml	
+++ b/.idea/modules.xml	
@@ -3,6 +3,7 @@
   <component name="ProjectModuleManager">
     <modules>
       <module fileurl="file://$PROJECT_DIR$/.idea/TPI.iml" filepath="$PROJECT_DIR$/.idea/TPI.iml" />
+      <module fileurl="file://$PROJECT_DIR$/.idea/auxiliares.cpp.iml" filepath="$PROJECT_DIR$/.idea/auxiliares.cpp.iml" />
     </modules>
   </component>
 </project>
\ No newline at end of file
